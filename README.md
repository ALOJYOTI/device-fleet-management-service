Overview:

This project is a prototype backend system that simulates the management of a fleet of devices.
It provides a gRPC based API to register devices, track their states, and trigger mock long-running operations such as software updates.

This project demonstrates strong Low-Level Design, concurrency control, API design, state management, and production-grade backend engineering.

Technologies Used:

C++17
gRPC / Protocol Buffers
CMake
Python 3
Ubuntu 24.04.1 LTS (WSL2)

System Requirements:

This project was developed and tested on:
Ubuntu 24.04.1 LTS (via WSL2 on Windows)
g++ with C++17 support
CMake
gRPC & Protobuf (C++ toolchain)
Python 3
The project should run on any modern Linux distribution with equivalent tooling.

Setup, Build and Run Instruction:

Build C++ Backend:

sudo apt install build-essential cmake protobuf-compiler libgrpc++-dev cxxtest
From project root
cd server
mkdir -p build && cd build
cmake ../..
make -j

Run backend server:
./server/device_server

Setup Python CLI:

cd client
python3 -m venv venv
source venv/bin/activate
pip install grpcio grpcio-tools protobuf

Generate Python stubs:

cd ..
python -m grpc_tools.protoc \
  -I proto \
  --python_out=client \
  --grpc_python_out=client \
  proto/device.proto

Unit Testing:
The project includes comprehensive unit tests for core backend components
using the CxxTest framework.

Unit Test Coverage:
DeviceManager API
ActionManager API
Validation and failure scenarios
Concurrency and worker thread behavior

Run Unit Tests:

./tests/DeviceServerTests

The test runner is automatically generated by CMake using cxxtestgen.



device.proto service definition:

syntax = "proto3";

package devicefleet;

enum DeviceState {
    DEVICE_UNKNOWN = 0;
    IDLE = 1;
    BUSY = 2;
    OFFLINE = 3;
    MAINTENANCE = 4;
    UPDATING = 5;
    RECOVERING = 6;
    ERROR = 7;
}

enum ActionType {
  ACTION_UNKNOWN = 0;
  SOFTWARE_UPDATE = 1;
}

enum SoftwareVersion {
  VERSION_UNKNOWN = 0;
  V1_0 = 1;
  V1_1 = 2;
  V2_0 = 3;
}

enum ActionStatus {
  ACTION_STATUS_UNKNOWN = 0;
  PENDING = 1;
  RUNNING = 2;
  COMPLETED = 3;
  FAILED = 4;
}

message ActionParams {
  SoftwareVersion target_version = 1;
}

message Device {
  string device_id = 1;
  DeviceState device_state = 2;
}

message RegisterDeviceRequest {
  string device_id = 1;
  DeviceState initial_state = 2;
}

message RegisterDeviceResponse {
  bool success = 1;
  string message = 2;
}

message SetDeviceStatusRequest {
  string device_id = 1;
  DeviceState state = 2;
}

message SetDeviceStatusResponse {
  bool success = 1;
  string message = 2;
}

message GetDeviceInfoRequest {
  string device_id = 1;
}

message GetDeviceInfoResponse {
  Device device = 1;
  bool found = 2;
}

message ListDevicesRequest {}

message ListDevicesResponse {
  repeated Device devices = 1;
}

message InitiateDeviceActionRequest {
  string device_id = 1;
  ActionType action_type = 2;
  ActionParams params = 3;
}

message InitiateDeviceActionResponse {
  bool success = 1;
  string message = 2;
  string action_id = 3;
}

message GetDeviceActionStatusRequest {
  string action_id = 1;
}

message GetDeviceActionStatusResponse {
  ActionStatus status = 1;
  bool found = 2;
}

service DeviceFleetService {
  rpc RegisterDevice(RegisterDeviceRequest) returns (RegisterDeviceResponse);
  rpc SetDeviceStatus(SetDeviceStatusRequest) returns (SetDeviceStatusResponse);
  rpc GetDeviceInfo(GetDeviceInfoRequest) returns (GetDeviceInfoResponse);
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);
  rpc InitiateDeviceAction(InitiateDeviceActionRequest)
      returns (InitiateDeviceActionResponse);
  rpc GetDeviceActionStatus(GetDeviceActionStatusRequest)
      returns (GetDeviceActionStatusResponse);
}


Architecture:

The system consists of the following main components:
C++ Backend Service
gRPC server
In-memory storage for devices and actions
Worker threads for asynchronous action execution
Protocol Buffers API Layer
Defines services and message formats
Python CLI Client
Command line interface for interacting with the backend

Architecture Overview:
Python CLI  →  gRPC API  →  DeviceServiceImpl
                               |
                               |
                     +--------------------+
                     | Application Layer  |
                     +--------------------+
                         ↙            ↘
                +------------+     +-------------+
                | DeviceMgr  |     | ActionMgr   |
                +------------+     +-------------+
                                        |
                                        ↓
                                 Worker Pool (N threads)



How the backend and CLI interact:

The Python CLI sends requests via gRPC.
DeviceServiceImpl validates API input and orchestrates operations.
DeviceManager owns all device state (thread-safe).
ActionManager executes long-running actions using a bounded worker pool.
Results and state transitions are returned to the CLI.

Low-Level Design Highlights:

DeviceManager:
Owns all device state
Uses std::shared_mutex for high-concurrency reads
Enforces strict state transitions

ActionManager:
Fixed worker pool (bounded concurrency)
Bounded task queue for backpressure
Failure simulation & automatic recovery
Thread-safe action tracking

Concurrency Model:

| Component | Operation | Locking Strategy |
|----------|-----------|------------------|
| DeviceManager | Reads | `shared_lock<std::shared_mutex>` |
| DeviceManager | Writes | `unique_lock<std::shared_mutex>` |
| ActionManager | All access | `std::mutex` |
| Worker scheduling | Task queue | Condition variables |

Detailed examples of how to use the CLI to interact with the service for all API functions:

Register a New Device:
python cli.py register --id device1 --state IDLE
Expected output:
SUCCESS
Device Registered Successfully

Set Device Status (Manual Update):
python cli.py set-status --id device1 --state MAINTENANCE
Expected output:
SUCCESS
Device status updated

Get Status of a Specific Device:
python cli.py get-device-info --id device1
Expected output:
Device ID: device1
State: MAINTENANCE

List devices and their statuses:
python cli.py list-devices
Expected output:
Device ID: device1, State: IDLE
Device ID: device2, State: MAINTENANCE

Trigger Software Update Action:
python cli.py start-action --id device1 --type SOFTWARE_UPDATE --version V2_0
Expected output:
Action initiated. Action ID: action_1

Poll Status of an Ongoing Action:
python cli.py get-action-status --action-id action_1
Expected output(while running):
Action Status: RUNNING
Expected output(while completed):
Action Status: COMPLETED

Observe Device State Transitions During Action:
python cli.py get-device-info --id device1
Example transitions:
IDLE → UPDATING → ERROR → RECOVERING → IDLE

Testing Strategy:
Unit tests isolate DeviceManager and ActionManager behavior.
ActionManager is tested with a mock DeviceManager to verify
concurrency, validation, and worker thread behavior.
Tests avoid long waits by validating state transitions
(PENDING → RUNNING) instead of waiting for full action completion.


Design Scope, Simplifications & Future Improvements:

Design Scope (as per assignment):
Devices are uniquely identified by device_id.
The backend runs as a single instance.
All data is maintained in memory.
The only supported action type is SOFTWARE_UPDATE.

Assumptions:
SOFTWARE_UPDATE action only allowed from IDLE state

Simplifications (Design Decisions):
No persistent database integration.
No user management or access control.
Failure behavior is simulated using random outcomes.
No retry mechanism for failed actions or transient network failures.
gRPC communication uses insecure channels (no TLS).
No log rotation or external logging framework.
Setting a device to the same state repeatedly is not treated as an error.

Future Improvements:
Implement background cleanup for completed actions.
Introduce persistent storage (e.g., SQLite, Redis).
Add retry mechanisms and exponential backoff for transient failures.
Add authentication, authorization, and rate limiting.
Provide event-based or streaming notifications to the CLI when actions complete.
Implement graceful shutdown and signal handling.
Integrate centralized logging and log rotation.
Validate and prevent redundant device state transitions.
Add device grouping and bulk action execution.
Support additional action types beyond SOFTWARE_UPDATE.

Project Structure:

proto/      → gRPC API definitions
server/     → C++ backend
client/     → Python CLI
tests/      → Unit tests (CxxTest)

License:
MIT License
